From 88a7af51d8ef4d9199ff9073bc09eabb5182fe80 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Tue, 19 Jun 2018 13:14:13 +0200
Subject: [PATCH 2/3] mlock.2, mlock2.2: document mlock2(2) and MCL_ONFAULT
---
 man-pages/man2/mlock.2 | 152 ++++++++++++++++++++++++++++++++++++-----
 1 file changed, 136 insertions(+), 16 deletions(-)

diff --git a/man-pages/man2/mlock.2 b/man-pages/man2/mlock.2
index 27189d8..595c9e9 100644
--- a/man-pages/man2/mlock.2
+++ b/man-pages/man2/mlock.2
@@ -23,35 +23,39 @@
 .\" <http://www.gnu.org/licenses/>.
 .\" %%%LICENSE_END
 .\"
-.TH MLOCK 2 2011-09-14 "Linux" "Linux Programmer's Manual"
+.TH MLOCK 2 2015-08-28 "Linux" "Linux Programmer's Manual"
 .SH NAME
-mlock, munlock, mlockall, munlockall \- lock and unlock memory
+mlock, mlock2, munlock, mlockall, munlockall \- lock and unlock memory
 .SH SYNOPSIS
 .nf
 .B #include <sys/mman.h>
 .sp
 .BI "int mlock(const void *" addr ", size_t " len );
+.BI "int mlock2(const void *" addr ", size_t " len ", int " flags );
 .BI "int munlock(const void *" addr ", size_t " len );
 .sp
 .BI "int mlockall(int " flags );
 .B int munlockall(void);
 .fi
 .SH DESCRIPTION
-.BR mlock ()
+.BR mlock (),
+.BR mlock2 (),
 and
 .BR mlockall ()
-respectively lock part or all of the calling process's virtual address
+lock part or all of the calling process's virtual address
 space into RAM, preventing that memory from being paged to the
 swap area.
+
 .BR munlock ()
 and
 .BR munlockall ()
 perform the converse operation,
-respectively unlocking part or all of the calling process's virtual
+unlocking part or all of the calling process's virtual
 address space, so that pages in the specified virtual address range may
 once more to be swapped out if required by the kernel memory manager.
+
 Memory locking and unlocking are performed in units of whole pages.
-.SS mlock() and munlock()
+.SS mlock(), mlock2(), and munlock()
 .BR mlock ()
 locks pages in the address range starting at
 .I addr
@@ -62,6 +66,41 @@ All pages that contain a part of the specified address range are
 guaranteed to be resident in RAM when the call returns successfully;
 the pages are guaranteed to stay in RAM until later unlocked.
 
+.BR mlock2 ()
+.\" commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
+.\" commit de60f5f10c58d4f34b68622442c0e04180367f3f
+.\" commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
+also locks pages in the specified range starting at
+.I addr
+and continuing for
+.I len
+bytes.
+However, the state of the pages contained in that range after the call
+returns successfully will depend on the value in the
+.I flags
+argument.
+
+The
+.I flags
+argument can be either 0 or the following constant:
+.TP
+.B MLOCK_ONFAULT
+Lock pages that are currently resident and mark the entire range to have
+pages locked when they are populated by the page fault.
+.PP
+
+If
+.I flags
+is 0,
+.BR mlock2 ()
+behaves exactly the same as
+.BR mlock ().
+
+Note: currently, there is not a glibc wrapper for
+.BR mlock2 (),
+so it will need to be invoked using
+.BR syscall (2).
+
 .BR munlock ()
 unlocks pages in the address range starting at
 .I addr
@@ -93,9 +132,36 @@ the process.
 .B MCL_FUTURE
 Lock all pages which will become mapped into the address space of the
 process in the future.
-These could be for instance new pages required
-by a growing heap and stack as well as new memory mapped files or
+These could be, for instance, new pages required
+by a growing heap and stack as well as new memory-mapped files or
 shared memory regions.
+.TP
+.BR MCL_ONFAULT " (since Linux 4.4)"
+Used together with
+.BR MCL_CURRENT ,
+.BR MCL_FUTURE ,
+or both.
+Mark all current (with
+.BR MCL_CURRENT )
+or future (with
+.BR MCL_FUTURE )
+mappings to lock pages when they are faulted in.
+When used with
+.BR MCL_CURRENT ,
+all present pages are locked, but
+.BR mlockall ()
+will not fault in non-present pages.
+When used with
+.BR MCL_FUTURE ,
+all future mappings will be marked to lock pages when they are faulted
+in, but they will not be populated by the lock when the mapping is
+created.
+.B MCL_ONFAULT
+must be used with either
+.B MCL_CURRENT
+or
+.B MCL_FUTURE
+or both.
 .PP
 If
 .B MCL_FUTURE
@@ -148,7 +214,8 @@ to perform the requested operation.
 .\"SVr4 documents an additional EAGAIN error code.
 .LP
 For
-.BR mlock ()
+.BR mlock (),
+.BR mlock2 (),
 and
 .BR munlock ():
 .TP
@@ -157,9 +224,9 @@ Some or all of the specified address range could not be locked.
 .TP
 .B EINVAL
 The result of the addition
-.IR start + len
+.IR addr + len
 was less than
-.IR start
+.IR addr
 (e.g., the addition may have resulted in an overflow).
 .TP
 .B EINVAL
@@ -172,19 +239,36 @@ Some of the specified address range does not correspond to mapped
 pages in the address space of the process.
 .LP
 For
-.BR mlockall ():
+.BR mlock2 ():
 .TP
 .B EINVAL
 Unknown \fIflags\fP were specified.
 .LP
 For
+.BR mlockall ():
+.TP
+.B EINVAL
+Unknown \fIflags\fP were specified or
+.B MCL_ONFAULT
+was specified without either
+.B MCL_FUTURE
+or
+.BR MCL_CURRENT .
+.LP
+For
 .BR munlockall ():
 .TP
 .B EPERM
 (Linux 2.6.8 and earlier) The caller was not privileged
 .RB ( CAP_IPC_LOCK ).
+.SH VERSIONS
+.BR mlock2 (2)
+is available since Linux 4.4.
 .SH CONFORMING TO
-POSIX.1-2001, SVr4.
+POSIX.1-2001, POSIX.1-2008, SVr4.
+
+mlock2 ()
+is Linux specific.
 .SH AVAILABILITY
 On POSIX systems on which
 .BR mlock ()
@@ -247,6 +331,15 @@ Memory locks are not inherited by a child created via
 and are automatically removed (unlocked) during an
 .BR execve (2)
 or when the process terminates.
+The
+.BR mlockall ()
+.B MCL_FUTURE
+and
+.B MCL_FUTURE | MCL_ONFAULT
+settings are not inherited by a child created via
+.BR fork (2)
+and are cleared during an
+.BR execve (2).
 
 The memory lock on an address range is automatically removed
 if the address range is unmapped via
@@ -254,7 +347,8 @@ if the address range is unmapped via
 
 Memory locks do not stack, that is, pages which have been locked several times
 by calls to
-.BR mlock ()
+.BR mlock (),
+.BR mlock2 (),
 or
 .BR mlockall ()
 will be unlocked by a single call to
@@ -264,15 +358,40 @@ for the corresponding range or by
 Pages which are mapped to several locations or by several processes stay
 locked into RAM as long as they are locked at least at one location or by
 at least one process.
+
+If a call to
+.BR mlockall ()
+which uses the
+.B MCL_FUTURE
+flag is followed by another call that does not specify this flag, the
+changes made by the
+.B MCL_FUTURE
+call will be lost.
+
+The
+.BR mlock2 ()
+.B MLOCK_ONFAULT
+flag and the
+.BR mlockall ()
+.B MCL_ONFAULT
+flag allow efficient memory locking for applications that deal with
+large mappings where only a (small) portion of pages in the mapping are touched.
+In such cases, locking all of the pages in a mapping would incur
+a significant penalty for memory locking.
 .SS Linux notes
 Under Linux,
-.BR mlock ()
+.BR mlock (),
+.BR mlock2 (),
 and
 .BR munlock ()
 automatically round
 .I addr
 down to the nearest page boundary.
-However, POSIX.1-2001 allows an implementation to require that
+However, the POSIX.1 specification of
+.BR mlock ()
+and
+.BR munlock ()
+allows an implementation to require that
 .I addr
 is page aligned, so portable applications should ensure this.
 
@@ -284,6 +403,7 @@ file shows how many kilobytes of memory the process with ID
 .I PID
 has locked using
 .BR mlock (),
+.BR mlock2 (),
 .BR mlockall (),
 and
 .BR mmap (2)
-- 
2.17.1

